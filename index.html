<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>點線面遊戲 - 形狀填滿動畫版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
            overflow: hidden;
            font-family: "Microsoft JhengHei", sans-serif;
            touch-action: none;
            user-select: none;
        }

        /* --- UI 元素 --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* 設定按鈕 (白色邊框) */
        #settings-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            background-color: #333;
            border: 3px solid #FFFFFF;
            border-radius: 10px;
            color: white;
            font-size: 30px;
            pointer-events: auto;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 設定選單 */
        #settings-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 500px;
            background-color: #222;
            border: 4px solid #FFD700;
            border-radius: 20px;
            padding: 20px;
            pointer-events: auto;
            z-index: 1002;
            color: #FFF;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        .setting-group { margin-bottom: 20px; }
        .setting-group label { display: block; font-size: 1.5rem; margin-bottom: 10px; color: #FFD700; }
        .btn-group { display: flex; gap: 10px; }
        
        .option-btn {
            flex: 1;
            padding: 15px;
            font-size: 1.2rem;
            background: #444;
            color: #FFF;
            border: 2px solid #666;
            border-radius: 10px;
            cursor: pointer;
        }
        .option-btn.active {
            background-color: #00AAFF;
            border-color: #FFF;
            font-weight: bold;
        }

        input[type=range] { width: 100%; height: 30px; }

        #close-settings {
            width: 100%;
            padding: 15px;
            font-size: 1.5rem;
            background-color: #00CC00;
            color: white;
            border: none;
            border-radius: 10px;
            margin-top: 10px;
            cursor: pointer;
        }

        /* 文字顯示區域 (白色字體) */
        #question-text {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            color: #FFFFFF;
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
            pointer-events: none;
        }

        /* 眼動游標 */
        #gaze-cursor {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 4px solid #FFFF00;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 999;
            box-shadow: 0 0 20px #FFFF00;
            display: none;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        #big-start-btn {
            padding: 30px 60px;
            font-size: 3rem;
            border-radius: 30px;
            background: #FFD700;
            border: none;
            cursor: pointer;
            animation: pulse 2s infinite;
            font-weight: bold;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 20px #FFD700; }
            50% { transform: scale(1.1); box-shadow: 0 0 50px #FFD700; }
            100% { transform: scale(1); box-shadow: 0 0 20px #FFD700; }
        }
    </style>
</head>
<body>

    <div id="settings-btn">⚙️</div>
    <div id="settings-modal">
        <div class="setting-group">
            <label>形狀選擇</label>
            <div class="btn-group">
                <button class="option-btn active" onclick="setShape('square', this)">正方形</button>
                <button class="option-btn" onclick="setShape('circle', this)">圓形</button>
                <button class="option-btn" onclick="setShape('triangle', this)">三角形</button>
            </div>
        </div>
        <div class="setting-group">
            <label>注視時間: <span id="time-display">0.5</span> 秒</label>
            <input type="range" id="dwell-slider" min="0.2" max="3.0" step="0.1" value="0.5">
        </div>
        <button id="close-settings">確認並重新開始</button>
    </div>

    <div id="ui-layer">
        <div id="question-text"></div>
    </div>

    <div id="gaze-cursor"></div>

    <div id="start-overlay">
        <button id="big-start-btn">開始遊戲</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- 聲音系統 (Audio Context) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;

    function initAudio() {
        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    let oscillator = null;
    let gainNode = null;

    // 1. 面的填充音效 (連續上行)
    function startFillingSound() {
        if (!audioCtx) return;
        oscillator = audioCtx.createOscillator();
        gainNode = audioCtx.createGain();
        oscillator.type = 'sine';
        oscillator.frequency.value = 220; 
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); 
        oscillator.start();
    }

    function updateFillingSound(progress) { 
        if (oscillator) {
            let freq = 220 + (progress * 660); // A3 -> A5
            oscillator.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.1);
        }
    }

    function stopFillingSound() {
        if (oscillator) {
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            oscillator.stop(audioCtx.currentTime + 0.1);
            oscillator = null;
        }
    }

    // 2. 興奮音效 (Do-Mi-So-Mi-So)
    function playExcitedSound() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const notes = [
            { freq: 523.25, start: 0, dur: 0.4 },     // Do
            { freq: 659.25, start: 0.4, dur: 0.4 },   // Mi
            { freq: 783.99, start: 0.8, dur: 0.4 },   // So
            { freq: 659.25, start: 1.2, dur: 0.4 },   // Mi
            { freq: 783.99, start: 1.6, dur: 1.4 }    // So (Long)
        ];

        notes.forEach(note => {
            let osc = audioCtx.createOscillator();
            let gain = audioCtx.createGain();
            osc.type = 'triangle'; 
            osc.frequency.value = note.freq;

            gain.gain.setValueAtTime(0, now + note.start);
            gain.gain.linearRampToValueAtTime(0.2, now + note.start + 0.05); 
            gain.gain.exponentialRampToValueAtTime(0.001, now + note.start + note.dur); 

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now + note.start);
            osc.stop(now + note.start + note.dur);
        });
    }

    // 3. 成功過關音效
    function playSuccessSound() {
        if (!audioCtx) return;
        let notes = [523.25, 659.25, 783.99, 1046.50]; // C E G C
        let now = audioCtx.currentTime;
        notes.forEach((freq, i) => {
            let osc = audioCtx.createOscillator();
            let gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, now + i*0.15);
            gain.gain.exponentialRampToValueAtTime(0.001, now + i*0.15 + 0.5);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now + i*0.15);
            osc.stop(now + i*0.15 + 0.5);
        });
    }

    // 4. 笑聲
    function playLaughSound() {
        if (!audioCtx) return;
        let now = audioCtx.currentTime;
        for(let i=0; i<3; i++) {
            let osc = audioCtx.createOscillator();
            let gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(400 + Math.random()*100, now + i*0.15);
            osc.frequency.exponentialRampToValueAtTime(300, now + i*0.15 + 0.1);
            gain.gain.setValueAtTime(0.3, now + i*0.15);
            gain.gain.exponentialRampToValueAtTime(0.01, now + i*0.15 + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now + i*0.15);
            osc.stop(now + i*0.15 + 0.1);
        }
    }

    // --- 語音 ---
    let isSpeaking = false;
    function speak(text, callback) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'zh-HK'; 
        utterance.rate = 0.9;
        isSpeaking = true;
        utterance.onend = () => { 
            isSpeaking = false; 
            if(callback) callback();
        };
        window.speechSynthesis.speak(utterance);
        
        if(text.includes('喺邊到') || text.includes('無角')) {
            document.getElementById('question-text').innerText = text;
        }
    }

    // --- 遊戲狀態變數 ---
    const CONFIG = {
        dwellTime: 500, 
        targetShape: 'square',
        hitTolerance: 130 
    };

    let gameState = 'INIT';
    let currentFillProgress = 0;
    
    // 外觀
    let shapeColor = '#FFD700';
    let faceStyle = 0;

    let shape = {
        x: 0, y: 0, size: 0,
        points: [],
        midpoints: [],
        cornersFound: [],
        edgesFound: []
    };

    let mouseX = 0, mouseY = 0;
    let hoverStartTime = 0;
    let hoveringTargetId = null;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const cursor = document.getElementById('gaze-cursor');

    // UI Logic
    const settingsBtn = document.getElementById('settings-btn');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettingsBtn = document.getElementById('close-settings');
    const dwellSlider = document.getElementById('dwell-slider');
    const timeDisplay = document.getElementById('time-display');

    settingsBtn.onclick = () => { settingsModal.style.display = 'block'; };
    
    window.setShape = (type, btn) => {
        CONFIG.targetShape = type;
        document.querySelectorAll('.option-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
    };

    dwellSlider.oninput = (e) => {
        timeDisplay.innerText = e.target.value;
        CONFIG.dwellTime = e.target.value * 1000;
    };

    closeSettingsBtn.onclick = () => {
        settingsModal.style.display = 'none';
        resetGameWithRandomAttributes();
    };

    document.getElementById('big-start-btn').onclick = () => {
        initAudio();
        document.getElementById('start-overlay').style.display = 'none';
        resetGameWithRandomAttributes();
    };

    // --- 幾何計算 ---
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        shape.x = canvas.width / 2;
        shape.y = canvas.height * 0.55; // 稍微下移
        shape.size = Math.min(canvas.width, canvas.height) * 0.3;
        calculateGeometry();
    }
    window.addEventListener('resize', resize);

    function randomizeAppearance() {
        const colors = ['#00FF00', '#00CCFF', '#FF00CC', '#FF4500', '#3366FF'];
        shapeColor = colors[Math.floor(Math.random() * colors.length)];
        faceStyle = Math.floor(Math.random() * 3);
    }

    function calculateGeometry() {
        shape.points = [];
        shape.midpoints = [];
        let s = shape.size;

        if (CONFIG.targetShape === 'square') {
            shape.points = [
                {x: shape.x - s, y: shape.y - s},
                {x: shape.x + s, y: shape.y - s},
                {x: shape.x + s, y: shape.y + s},
                {x: shape.x - s, y: shape.y + s}
            ];
            shape.midpoints = [
                {x: shape.x, y: shape.y - s},
                {x: shape.x + s, y: shape.y},
                {x: shape.x, y: shape.y + s},
                {x: shape.x - s, y: shape.y}
            ];
        } else if (CONFIG.targetShape === 'triangle') {
            let r = s * 1.2;
            let angles = [-Math.PI/2, Math.PI/6, 5*Math.PI/6];
            shape.points = angles.map(a => ({
                x: shape.x + r * Math.cos(a),
                y: shape.y + r * Math.sin(a)
            }));
            for(let i=0; i<3; i++) {
                let p1 = shape.points[i];
                let p2 = shape.points[(i+1)%3];
                shape.midpoints.push({
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                });
            }
        } else if (CONFIG.targetShape === 'circle') {
            shape.points = [];
            shape.midpoints = [{x: shape.x, y: shape.y - s}];
        }

        shape.cornersFound = new Array(shape.points.length).fill(false);
        shape.edgesFound = new Array(shape.midpoints.length).fill(false);
    }

    function resetGameWithRandomAttributes() {
        resize();
        randomizeAppearance();
        currentFillProgress = 0;
        startPlaneStage();
    }

    function getShapeName() {
        if(CONFIG.targetShape === 'square') return '正方形';
        if(CONFIG.targetShape === 'circle') return '圓形';
        if(CONFIG.targetShape === 'triangle') return '三角形';
    }

    function startPlaneStage() {
        gameState = 'PLANE';
        calculateGeometry();
        currentFillProgress = 0;
        speak(`${getShapeName()}嘅面喺邊到？`);
    }

    function startCornerStage() {
        gameState = 'CORNERS';
        if (CONFIG.targetShape === 'circle') {
            speak("圓形無角", () => {
                setTimeout(startEdgeStage, 1000);
            });
        } else {
            speak(`${getShapeName()}嘅角喺邊到？`);
        }
    }

    function startEdgeStage() {
        gameState = 'EDGES';
        speak(`${getShapeName()}嘅邊喺邊到？`);
    }

    function checkFinish() {
        speak(`搵到所有邊啦，做得好！`, () => {
            playSuccessSound();
            setTimeout(() => {
                resetGameWithRandomAttributes();
            }, 3000);
        });
    }

    // --- 輸入處理 ---
    function handleInput(x, y) {
        mouseX = x;
        mouseY = y;
        cursor.style.left = x + 'px';
        cursor.style.top = y + 'px';
        cursor.style.display = 'block';
    }
    document.addEventListener('mousemove', e => handleInput(e.clientX, e.clientY));
    document.addEventListener('touchmove', e => {
        e.preventDefault();
        handleInput(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    function dist(x1, y1, x2, y2) { return Math.sqrt((x1-x2)**2 + (y1-y2)**2); }

    // --- 遊戲邏輯更新 ---
    function update() {
        if (isSpeaking) return;

        let targetHit = false;
        let targetId = null;

        // 1. 面
        if (gameState === 'PLANE' && currentFillProgress < 1.0) {
            if (dist(mouseX, mouseY, shape.x, shape.y) < shape.size * 0.7) { 
                targetHit = true;
                targetId = 'face';
            }
        }

        // 2. 角
        if (gameState === 'CORNERS') {
            for(let i=0; i<shape.points.length; i++) {
                if(!shape.cornersFound[i]) {
                    if (dist(mouseX, mouseY, shape.points[i].x, shape.points[i].y) < CONFIG.hitTolerance) {
                        targetHit = true;
                        targetId = `corner-${i}`;
                    }
                }
            }
        }

        // 3. 邊
        if (gameState === 'EDGES') {
            if (CONFIG.targetShape === 'circle') {
                let d = dist(mouseX, mouseY, shape.x, shape.y);
                if (Math.abs(d - shape.size) < CONFIG.hitTolerance && !shape.edgesFound[0]) {
                    targetHit = true;
                    targetId = 'edge-0';
                }
            } else {
                for(let i=0; i<shape.midpoints.length; i++) {
                    if(!shape.edgesFound[i]) {
                        if (dist(mouseX, mouseY, shape.midpoints[i].x, shape.midpoints[i].y) < CONFIG.hitTolerance) {
                            targetHit = true;
                            targetId = `edge-${i}`;
                        }
                    }
                }
            }
        }

        if (targetHit) {
            if (gameState === 'PLANE' && targetId === 'face') {
                if (oscillator === null) startFillingSound();
                currentFillProgress += 0.01; 
                updateFillingSound(currentFillProgress);
                
                if (currentFillProgress >= 1.0) {
                    currentFillProgress = 1.0;
                    stopFillingSound();
                    playLaughSound();
                    speak("啱啦，呢個係面。", () => {
                        setTimeout(startCornerStage, 1000);
                    });
                }
                return;
            }

            if (hoveringTargetId === targetId) {
                let elapsed = Date.now() - hoverStartTime;
                if (elapsed > CONFIG.dwellTime) {
                    triggerAction(targetId);
                    hoveringTargetId = null;
                }
            } else {
                hoveringTargetId = targetId;
                hoverStartTime = Date.now();
            }
        } else {
            if (gameState === 'PLANE') stopFillingSound();
            hoveringTargetId = null;
        }
    }

    function triggerAction(id) {
        if (id.startsWith('corner')) {
            let idx = parseInt(id.split('-')[1]);
            shape.cornersFound[idx] = true;
            playExcitedSound(); 
            
            if (shape.cornersFound.every(c => c)) {
                speak("揾到所有角啦，做得好！", () => {
                    setTimeout(startEdgeStage, 2500); 
                });
            } else {
                speak("啱，呢個係角。");
            }
        }
        else if (id.startsWith('edge')) {
            let idx = parseInt(id.split('-')[1]);
            shape.edgesFound[idx] = true;
            playExcitedSound(); 
            
            let count = shape.edgesFound.filter(Boolean).length;
            let countText = ['一', '兩', '三', '四'][count-1];
            
            if (shape.edgesFound.every(e => e)) {
                checkFinish();
            } else {
                speak(`揾到${countText}條邊啦。`);
            }
        }
    }

    // --- 繪圖輔助 ---
    function defineShapePath(ctx, scale = 1.0) {
        ctx.beginPath();
        if (CONFIG.targetShape === 'circle') {
            ctx.arc(shape.x, shape.y, shape.size * scale, 0, Math.PI*2);
        } else if (CONFIG.targetShape === 'square') {
            let s = shape.size * scale;
            ctx.rect(shape.x - s, shape.y - s, s * 2, s * 2);
        } else if (CONFIG.targetShape === 'triangle') {
            let r = shape.size * 1.2 * scale;
            let angles = [-Math.PI/2, Math.PI/6, 5*Math.PI/6];
            let p0 = {x: shape.x + r * Math.cos(angles[0]), y: shape.y + r * Math.sin(angles[0])};
            ctx.moveTo(p0.x, p0.y);
            for(let i=1; i<3; i++) {
                ctx.lineTo(shape.x + r * Math.cos(angles[i]), shape.y + r * Math.sin(angles[i]));
            }
            ctx.closePath();
        }
    }

    function drawStar(ctx, cx, cy, radius, color) {
        let spikes = 5;
        let outerRadius = radius;
        let innerRadius = radius / 2;
        let rot = Math.PI / 2 * 3;
        let x = cx, y = cy;
        let step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;
            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    function drawFace(ctx, x, y, size) {
        ctx.fillStyle = '#000';
        let eyeOffset = size / 3;
        let eyeSize = size / 8;
        
        if (faceStyle === 0) {
            ctx.beginPath(); ctx.arc(x - eyeOffset, y - eyeOffset, eyeSize, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(x + eyeOffset, y - eyeOffset, eyeSize, 0, Math.PI*2); ctx.fill();
        } else if (faceStyle === 1) {
            ctx.lineWidth = 5; ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.arc(x - eyeOffset, y - eyeOffset, eyeSize, Math.PI, 0); ctx.stroke();
            ctx.beginPath(); ctx.arc(x + eyeOffset, y - eyeOffset, eyeSize, Math.PI, 0); ctx.stroke();
        } else {
            ctx.fillRect(x - eyeOffset - eyeSize, y - eyeOffset, eyeSize*2, 5);
            ctx.fillRect(x + eyeOffset - eyeSize, y - eyeOffset, eyeSize*2, 5);
        }

        ctx.beginPath();
        if (faceStyle === 0) ctx.arc(x, y + size/5, size/3, 0, Math.PI);
        else if (faceStyle === 1) ctx.ellipse(x, y + size/3, size/4, size/6, 0, 0, Math.PI*2);
        else {
            ctx.moveTo(x - size/3, y + size/3);
            ctx.quadraticCurveTo(x, y + size/2, x + size/3, y + size/3);
        }
        ctx.lineWidth = 5;
        ctx.strokeStyle = '#000';
        ctx.stroke();
    }

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 1. Fill Logic (修改: 使用 scale 縮放圖形)
        // 底色
        if (gameState === 'PLANE') {
             ctx.fillStyle = '#222';
             defineShapePath(ctx, 1.0);
             ctx.fill();
        }
        
        // 進度填充 (使用相同形狀，但根據 currentFillProgress 縮放)
        if (currentFillProgress > 0) {
            ctx.fillStyle = shapeColor;
            defineShapePath(ctx, currentFillProgress); // 使用縮放參數
            ctx.fill();
        }

        // 2. Outline (Yellow)
        defineShapePath(ctx, 1.0); 
        ctx.lineWidth = 12; 
        ctx.strokeStyle = '#FFFF00'; 
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();

        // 3. Face
        if (currentFillProgress >= 1.0) {
            drawFace(ctx, shape.x, shape.y, shape.size);
        }

        // 4. Corners
        if (gameState === 'CORNERS') {
            shape.points.forEach((p, i) => {
                if (!shape.cornersFound[i]) {
                    let wobble = Math.sin(Date.now()/200) * 5;
                    drawStar(ctx, p.x, p.y, 45 + wobble, '#FF0055'); 
                    
                    if (hoveringTargetId === `corner-${i}`) {
                        ctx.strokeStyle = '#FFFF00';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, CONFIG.hitTolerance, 0, Math.PI*2);
                        ctx.stroke();
                    }
                } else {
                    drawStar(ctx, p.x, p.y, 20, '#00FF00');
                }
            });
        }

        // 5. Edges
        if (gameState === 'EDGES') {
            if (CONFIG.targetShape === 'circle') {
                if (shape.edgesFound[0] || hoveringTargetId === 'edge-0') {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 20;
                    ctx.beginPath();
                    ctx.arc(shape.x, shape.y, shape.size, 0, Math.PI*2);
                    ctx.stroke();
                }
            } else {
                shape.midpoints.forEach((mp, i) => {
                    let p1 = shape.points[i];
                    let p2 = shape.points[(i+1) % shape.points.length];
                    
                    if (shape.edgesFound[i] || hoveringTargetId === `edge-${i}`) {
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 20; 
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                });
            }
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }
    
    resize();
    loop();

</script>
</body>
</html>
